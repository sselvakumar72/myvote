    /**
     * Handles servlet request binding exceptions.
     * This can occur for issues like missing headers that are required.
     * Currently defers to the superclass implementation.
     */
    @Override
    protected ResponseEntity<Object> handleServletRequestBindingException(ServletRequestBindingException ex,
                                                                          HttpHeaders headers,
                                                                          HttpStatusCode status,
                                                                          WebRequest request) {
        String parameterName = null;
        if (ex instanceof MissingRequestHeaderException) {
            parameterName = ((MissingRequestHeaderException) ex).getHeaderName();
        } else if (ex instanceof MissingServletRequestParameterException) {
            parameterName = ((MissingServletRequestParameterException) ex).getParameterName();
        }

        String requestId = ErrorHandlerUtil.getRequestId();
        log.info("Request binding MyVoteError [RequestId: {}]: parameter:{}, {}",
                requestId, parameterName, ex.getMessage());

        return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                .body(MyVoteError.builder()
                        .code(ErrorCodes.INVALID_INPUT_CODE)
                        .message(ErrorMessages.INVALID_INPUT)
                        .description(MyVoteConstants.EMPTY_STRING).build();
    }

    /**
     * Handles malformed JSON or other message reading issues.
     * Returns FDX-compliant 400 MyVoteError response.
     */
    @Override
    protected ResponseEntity<Object> handleHttpMessageNotReadable(
            HttpMessageNotReadableException ex,
            @NotNull HttpHeaders headers,
            @NotNull HttpStatusCode status,
            @NotNull WebRequest request) {
        String requestId = ErrorHandlerUtil.getRequestId();
        log.info("HTTP message not readable [RequestId: {}]: {}", requestId, ex.getMessage());

        return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                .body(MyVoteError.builder()
                        .code(FdxErrorCodes.INVALID_PARAMETER)
                        .message(ErrorMessages.INVALID_REQUEST_FORMAT)
                        .description(MyVoteConstants.EMPTY_STRING).build();
    }

    /**
     * Handles method argument validation MyVoteErrors (e.g., @Valid annotation failures on request bodies).
     * Returns FDX-compliant 400 MyVoteError response.
     * <p>
     * Note: This overrides the @ExceptionHandler version below to ensure Spring's built-in
     * exception handling takes precedence.
     */
    @Override
    protected ResponseEntity<Object> handleMethodArgumentNotValid(
            MethodArgumentNotValidException ex,
            @NotNull HttpHeaders headers,
            @NotNull HttpStatusCode status,
            @NotNull WebRequest request) {
        String requestId = ErrorHandlerUtil.getRequestId();
        log.info("Method argument validation MyVoteError [RequestId: {}]:{}",
                requestId, ex.getMessage());

        return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                .body(MyVoteError.builder()
                        .code(FdxErrorCodes.INVALID_PARAMETER)
                        .message(ErrorMessages.VALIDATION_FAILED)
                        .description(MyVoteConstants.EMPTY_STRING).build();
    }

    /**
     * Handles type mismatch MyVoteErrors for request parameters (e.g., invalid enum values).
     * Returns FDX-compliant 400 MyVoteError response.
     */
    @Override
    protected ResponseEntity<Object> handleTypeMismatch(TypeMismatchException ex,
                                                        HttpHeaders headers,
                                                        HttpStatusCode status,
                                                        WebRequest request) {
        String requestId = ErrorHandlerUtil.getRequestId();
        log.info("Type mismatch MyVoteError [RequestId: {}]: {}", requestId, ex.getMessage());

        return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                .body(MyVoteError.builder()
                        .code(FdxErrorCodes.INVALID_PARAMETER)
                        .message(ErrorMessages.VALIDATION_FAILED)
                        .description(MyVoteConstants.EMPTY_STRING).build();
    }

    /**
     * Handles ConstraintViolationException from method parameter validation.
     * This is thrown when our custom validation annotations (@ValidAccountIdentifier, @ValidCustomerId, etc.) fail.
     */
    @ExceptionHandler(ConstraintViolationException.class)
    ResponseEntity<Error> handleConstraintViolationException(ConstraintViolationException ex) {
        String requestId = ErrorHandlerUtil.getRequestId();

        log.info("Constraint validation MyVoteError [RequestId: {}]:{}", requestId, ex.getMessage());

        return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                .body(MyVoteError.builder()
                        .code(FdxErrorCodes.INVALID_PARAMETER)
                        .message(ErrorMessages.VALIDATION_FAILED)
                        .description(MyVoteConstants.EMPTY_STRING).build();
    }


    /**
     * Handles BadRequestException for all validation MyVoteErrors (including our new validation framework)
     */
    @ExceptionHandler(BadRequestException.class)
    ResponseEntity<Error> handleBadRequestException(BadRequestException ex) {
        String requestId = ErrorHandlerUtil.getRequestId();
        log.info("Bad request validation MyVoteError [RequestId: {}]: {}", requestId, ex.getMessage());

        return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                .body(MyVoteError.builder()
                        .code(ErrorCodes.INVALID_INPUT_CODE)
                        .message(ErrorMessages.INVALID_INPUT)
                        .description(MyVoteConstants.EMPTY_STRING).build();
    }

    /**
     * Handles UpstreamBadRequestException for bad request sent from upstream services
     */
    @ExceptionHandler(UpstreamBadRequestException.class)
    ResponseEntity<Error> handleUpstreamBadRequestException(UpstreamBadRequestException ex) {
        String requestId = ErrorHandlerUtil.getRequestId();
        log.info("Bad request MyVoteError [RequestId: {}]: {}", requestId, ex.getMessage());

        return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                .body(MyVoteError.builder()
                        .code(ErrorCodes.INVALID_INPUT_CODE)
                        .message(ErrorMessages.INVALID_INPUT)
                        .description(MyVoteConstants.EMPTY_STRING).build();
    }

    /**
     * Handles AccountNotFoundException and returns FDX-compliant 404 response
     */
    @ExceptionHandler(AccountNotFoundException.class)
    ResponseEntity<Error> handleAccountNotFoundException(AccountNotFoundException ex) {
        String requestId = ErrorHandlerUtil.getRequestId();
        log.info("Account not found [RequestId: {}]: {}", requestId, ex.getMessage());

        return ResponseEntity.status(HttpStatus.NOT_FOUND)
                .body(MyVoteError.builder()
                        .code(FdxErrorCodes.ACCOUNT_NOT_FOUND)
                        .message(ErrorMessages.ACCOUNT_NOT_FOUND)
                        .description(MyVoteConstants.EMPTY_STRING).build();

    }

    /**
     * Handles PlanNotFoundException and returns FDX-compliant 404 response
     */
    @ExceptionHandler(PlanNotFoundException.class)
    ResponseEntity<Error> handlePlanNotFoundException(PlanNotFoundException ex) {
        String requestId = ErrorHandlerUtil.getRequestId();
        log.info("Plan not found [RequestId: {}]: {}", requestId, ex.getMessage());

        return ResponseEntity.status(HttpStatus.NOT_FOUND)
                .body(MyVoteError.builder()
                        .code(FdxErrorCodes.ACCOUNT_NOT_FOUND)
                        .message(ErrorMessages.PLAN_NOT_FOUND)
                        .description(MyVoteConstants.EMPTY_STRING).build();
    }

    /**
     * Handles CoverageNotFoundException and returns FDX-compliant 404 response
     */
    @ExceptionHandler(CoverageNotFoundException.class)
    ResponseEntity<Error> handleCoverageNotFoundException(CoverageNotFoundException ex) {
        String requestId = ErrorHandlerUtil.getRequestId();
        log.info("Coverage information not found [RequestId: {}]: {}", requestId, ex.getMessage());

        return ResponseEntity.status(HttpStatus.NOT_FOUND)
                .body(MyVoteError.builder()
                        .code(FdxErrorCodes.ACCOUNT_NOT_FOUND)
                        .message(ErrorMessages.COVERAGE_INFORMATION_NOT_FOUND)
                        .description(MyVoteConstants.EMPTY_STRING).build();
    }

    /**
     * Handles CustomerNotFoundException and returns FDX-compliant 404 response
     */
    @ExceptionHandler(CustomerNotFoundException.class)
    ResponseEntity<Error> handleCustomerNotFoundException(CustomerNotFoundException ex) {
        String requestId = ErrorHandlerUtil.getRequestId();
        log.info("Customer not found [RequestId: {}]: {}", requestId, ex.getMessage());

        return ResponseEntity.status(HttpStatus.NOT_FOUND)
                .body(MyVoteError.builder()
                        .code(FdxErrorCodes.CUSTOMER_NOT_FOUND)
                        .message(ErrorMessages.CUSTOMER_NOT_FOUND)
                        .description(MyVoteConstants.EMPTY_STRING).build();
    }

    /**
     * Handles InvalidAccountIdException for backward compatibility
     */
    @ExceptionHandler(InvalidAccountIdException.class)
    ResponseEntity<Error> handleInvalidAccountIdException(InvalidAccountIdException ex) {
        String requestId = ErrorHandlerUtil.getRequestId();
        log.info("Invalid account ID [RequestId: {}]: {}", requestId, ex.getMessage());

        return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                .body(MyVoteError.builder()
                        .code(FdxErrorCodes.INVALID_ACCOUNT_NUMBER_FORMAT)
                        .message(ErrorMessages.ACCOUNT_ID_FORMAT_IS_INVALID)
                        .description(MyVoteConstants.EMPTY_STRING).build();
    }

    /**
     * Handles IllegalArgumentException from request validators.
     * Returns FDX-compliant 400 MyVoteError response for validation failures.
     */
    @ExceptionHandler(IllegalArgumentException.class)
    ResponseEntity<Error> handleIllegalArgumentException(IllegalArgumentException ex) {
        String requestId = ErrorHandlerUtil.getRequestId();
        log.info("Validation MyVoteError [RequestId: {}]: {}", requestId, ex.getMessage());

        return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                .body(MyVoteError.builder()
                        .code(ErrorCodes.INVALID_INPUT_CODE)
                        .message(ErrorMessages.INVALID_INPUT)
                        .description(MyVoteConstants.EMPTY_STRING).build();
    }

    /**
     * Handles UpstreamServiceException and returns FDX-compliant 502 response
     */
    @ExceptionHandler(UpstreamServiceException.class)
    ResponseEntity<Error> handleUpstreamServiceException(UpstreamServiceException ex) {
        String requestId = ErrorHandlerUtil.getRequestId();
        log.error("Upstream service MyVoteError [RequestId: {}]: {}", requestId, ex.getMessage(), ex);

        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(MyVoteError.builder()
                        .code(FdxErrorCodes.SUBSYSTEM_UNAVAILABLE_CODE)
                        .message(ErrorMessages.SUBSYSTEM_UNAVAILABLE_ERROR)
                        .description(MyVoteConstants.EMPTY_STRING).build();
    }

    /**
     * Handles generic exceptions and returns FDX-compliant 500 response
     * Enhanced with request tracking for better debugging
     */
    @ExceptionHandler(Exception.class)
    ResponseEntity<Error> handleGenericException(Exception ex) {
        String requestId = ErrorHandlerUtil.getRequestId();
        log.error("Unexpected MyVoteError occurred [RequestId: {}]: {}", requestId, ex.getMessage(), ex);
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(MyVoteError.builder()
                        .code(ErrorCodes.INTERNAL_SERVER_ERROR_CODE)
                        .message(ErrorMessages.INTERNAL_SERVER_ERROR)
                        .description(MyVoteConstants.EMPTY_STRING).build();
    }
